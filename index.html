<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ë§ ì˜ ë“£ëŠ” ì‹œë°”ê²¬ (ë””ë²„ê¹…)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #87CEEB; 
            font-family: monospace;
        }
        
        #ui { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            padding: 20px; 
            background: rgba(0,0,0,0.8); 
            color: #0f0;
            z-index: 1000;
            box-sizing: border-box;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #log { 
            white-space: pre-wrap; 
            word-break: break-all;
            margin-bottom: 10px;
        }
        
        button { 
            padding: 15px 30px; 
            font-size: 18px; 
            cursor: pointer; 
            border-radius: 30px; 
            border: none; 
            background: #FFD700; 
            font-weight: bold;
            margin: 5px;
        }
        
        button:disabled {
            background: #ccc;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="log">ğŸ” ì´ˆê¸°í™” ì¤‘...\n</div>
        <button id="start-btn" disabled>ğŸ¤ ëª…ë ¹í•˜ê¸°</button>
        <button id="test-btn" disabled>ğŸ”„ ì• ë‹ˆë©”ì´ì…˜ í…ŒìŠ¤íŠ¸</button>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        { 
            "imports": { 
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
            } 
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const logEl = document.getElementById('log');
        const startBtn = document.getElementById('start-btn');
        const testBtn = document.getElementById('test-btn');

        function log(msg) {
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${time}] ${msg}\n`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }

        let scene, camera, renderer, mixer, controls, actions = {}, currentAction;
        let isRecognizing = false;
        const clock = new THREE.Clock();

        try {
            log('âœ“ Three.js ë¡œë“œ ì„±ê³µ');
            
            // ì¥ë©´ ë§Œë“¤ê¸°
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            log('âœ“ Scene ìƒì„± ì™„ë£Œ');

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 150);
            log('âœ“ Camera ì„¤ì • ì™„ë£Œ');

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            log('âœ“ Renderer ìƒì„± ì™„ë£Œ');

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 20, 0);
            controls.enableDamping = true;
            controls.update();
            log('âœ“ Controls ì„¤ì • ì™„ë£Œ');

            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            log('âœ“ ì¡°ëª… ì¶”ê°€ ì™„ë£Œ');

            // í…ŒìŠ¤íŠ¸ìš© ë°”ë‹¥ ê·¸ë¦¬ë“œ
            const gridHelper = new THREE.GridHelper(200, 20);
            scene.add(gridHelper);
            log('âœ“ ë°”ë‹¥ ê·¸ë¦¬ë“œ ì¶”ê°€');

            // í…ŒìŠ¤íŠ¸ìš© íë¸Œ (ëª¨ë¸ ë¡œë”© ì „ì—ë„ ë­”ê°€ ë³´ì´ê²Œ)
            const testCube = new THREE.Mesh(
                new THREE.BoxGeometry(20, 20, 20),
                new THREE.MeshStandardMaterial({ color: 0xff6b6b })
            );
            testCube.position.set(0, 10, 0);
            scene.add(testCube);
            log('âœ“ í…ŒìŠ¤íŠ¸ íë¸Œ ì¶”ê°€ (ì´ê²Œ ì•ˆ ë³´ì´ë©´ ë Œë”ë§ ë¬¸ì œ)');

            // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ëª¨ë¸ ì—†ì–´ë„ íë¸ŒëŠ” ë³´ì„)
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                if (mixer) mixer.update(delta);
                controls.update();
                testCube.rotation.y += 0.01; // íë¸Œ íšŒì „
                renderer.render(scene, camera);
            }
            animate();
            log('âœ“ ë Œë”ë§ ë£¨í”„ ì‹œì‘');

            // ì‹œë°”ê²¬ ë¡œë”©
            log('ğŸ“¦ shiba.glb ë¡œë”© ì‹œë„...');
            const loader = new GLTFLoader();
            
            loader.load(
                'shiba.glb',
                (gltf) => {
                    log('âœ… GLB íŒŒì¼ ë¡œë“œ ì„±ê³µ!');
                    
                    const model = gltf.scene;
                    
                    // ëª¨ë¸ ì •ë³´ ì¶œë ¥
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    log(`ğŸ“ ëª¨ë¸ í¬ê¸°: ${size.x.toFixed(1)} x ${size.y.toFixed(1)} x ${size.z.toFixed(1)}`);
                    
                    // ëª¨ë¸ ìœ„ì¹˜ ì¡°ì •
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.sub(center);
                    model.position.y = 0;
                    
                    scene.add(model);
                    scene.remove(testCube); // í…ŒìŠ¤íŠ¸ íë¸Œ ì œê±°
                    log('âœ“ ëª¨ë¸ ì¥ë©´ì— ì¶”ê°€');

                    // ì• ë‹ˆë©”ì´ì…˜ ì²´í¬
                    if (gltf.animations && gltf.animations.length > 0) {
                        log(`ğŸ¬ ë°œê²¬ëœ ì• ë‹ˆë©”ì´ì…˜ ìˆ˜: ${gltf.animations.length}`);
                        
                        mixer = new THREE.AnimationMixer(model);
                        
                        gltf.animations.forEach((clip, index) => {
                            const actionName = clip.name.toLowerCase();
                            actions[actionName] = mixer.clipAction(clip);
                            log(`  ${index + 1}. "${clip.name}" (${clip.duration.toFixed(2)}ì´ˆ)`);
                        });

                        // ì²« ë²ˆì§¸ ì• ë‹ˆë©”ì´ì…˜ ìë™ ì¬ìƒ
                        const firstAction = Object.values(actions)[0];
                        if (firstAction) {
                            currentAction = firstAction;
                            currentAction.play();
                            log(`â–¶ï¸ "${Object.keys(actions)[0]}" ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ ì‹œì‘`);
                        }

                        startBtn.disabled = false;
                        testBtn.disabled = false;
                        log('âœ… ëª¨ë“  ì¤€ë¹„ ì™„ë£Œ!');
                    } else {
                        log('âš ï¸ ì• ë‹ˆë©”ì´ì…˜ì´ ì—†ìŠµë‹ˆë‹¤');
                    }
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    log(`â³ ë¡œë”© ì¤‘... ${percent}%`);
                },
                (error) => {
                    log(`âŒ ë¡œë”© ì‹¤íŒ¨: ${error.message}`);
                    log('ğŸ’¡ í™•ì¸ì‚¬í•­:');
                    log('  1. shiba.glb íŒŒì¼ì´ index.htmlê³¼ ê°™ì€ í´ë”ì— ìˆë‚˜ìš”?');
                    log('  2. íŒŒì¼ëª… ì² ìê°€ ì •í™•í•œê°€ìš”? (ëŒ€ì†Œë¬¸ì êµ¬ë¶„)');
                    log('  3. ë¡œì»¬ì—ì„œ í…ŒìŠ¤íŠ¸ ì¤‘ì´ë¼ë©´ ì›¹ì„œë²„ê°€ í•„ìš”í•©ë‹ˆë‹¤');
                }
            );

            // í…ŒìŠ¤íŠ¸ ë²„íŠ¼
            testBtn.onclick = () => {
                const names = Object.keys(actions);
                if (names.length === 0) {
                    log('âš ï¸ ì• ë‹ˆë©”ì´ì…˜ì´ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                
                const randomName = names[Math.floor(Math.random() * names.length)];
                changeAction(randomName);
            };

            // ìŒì„±ì¸ì‹
            startBtn.onclick = () => {
                if (isRecognizing) return;
                
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (!SpeechRecognition) {
                    log('âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„±ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
                    return;
                }

                const recognition = new SpeechRecognition();
                recognition.lang = 'en-US';
                recognition.continuous = false;

                isRecognizing = true;
                startBtn.disabled = true;
                log('ğŸ¤ ë“£ëŠ” ì¤‘...');

                recognition.start();

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript.toLowerCase();
                    log(`ğŸ‘‚ ë“¤ìŒ: "${transcript}"`);
                    
                    if (transcript.includes('attack')) changeAction('attack');
                    else if (transcript.includes('bounce')) changeAction('bounce');
                    else if (transcript.includes('eat')) changeAction('eat');
                    else if (transcript.includes('click')) changeAction('clicked');
                    else if (transcript.includes('fear') || transcript.includes('sit')) changeAction('fear');
                    else {
                        log(`â“ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹: ${transcript}`);
                        log(`ì‚¬ìš© ê°€ëŠ¥: ${Object.keys(actions).join(', ')}`);
                    }
                };

                recognition.onerror = (event) => {
                    log(`âŒ ìŒì„±ì¸ì‹ ì˜¤ë¥˜: ${event.error}`);
                    isRecognizing = false;
                    startBtn.disabled = false;
                };

                recognition.onend = () => {
                    isRecognizing = false;
                    startBtn.disabled = false;
                };
            };

            function changeAction(name) {
                const next = actions[name.toLowerCase()];
                if (!next) {
                    log(`âŒ "${name}" ì• ë‹ˆë©”ì´ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`);
                    return;
                }
                
                if (currentAction !== next) {
                    if (currentAction) currentAction.fadeOut(0.3);
                    next.reset().fadeIn(0.3).play();
                    currentAction = next;
                    log(`â–¶ï¸ "${name}" ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ`);
                }
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

        } catch (error) {
            log(`ğŸ’¥ ì¹˜ëª…ì  ì˜¤ë¥˜: ${error.message}`);
            log(error.stack);
        }
    </script>
</body>
</html>
